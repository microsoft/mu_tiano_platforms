From a4a4316014aac9c52cea8ad0373033dda9cf8322 Mon Sep 17 00:00:00 2001
From: Kun Qin <kuqin@microsoft.com>
Date: Thu, 21 Aug 2025 16:54:57 -0700
Subject: [PATCH 2/2] Fixing SBSA MP usage (#4)

The existing TFA will fault the secondary cores when placing the TFA image in secure flash. This was because when the stmm image is trying to communicate with the secure flash for UEFI variable support, the flash will change mode to write. In the meantime, the secondary cores looping at `wfe` will be woken up which at this point the flash cannot be read.

This change will need to pair with PROGRAMMABLE_RESET_ADDRESS=1 build option to hold the secondary cores to loop at BL31 instead of BL1 which will remove the execute on flash dependency to avoid such issue.

Note that the holding pen logic is also updated to specifically handle the case of context losing suspend, where a wfi is used which makes the core not to wake up more until an explicit interrupt is issued.
---
 plat/qemu/common/aarch64/plat_helpers.S    | 27 +++++++++++++++++++++-
 plat/qemu/common/qemu_bl31_setup.c         |  6 +++++
 plat/qemu/qemu/include/platform_def.h      |  5 ++--
 plat/qemu/qemu_sbsa/include/platform_def.h |  5 ++--
 plat/qemu/qemu_sbsa/sbsa_pm.c              | 16 +++++++++++--
 5 files changed, 52 insertions(+), 7 deletions(-)

diff --git a/plat/qemu/common/aarch64/plat_helpers.S b/plat/qemu/common/aarch64/plat_helpers.S
index 08b281735..3cb72393c 100644
--- a/plat/qemu/common/aarch64/plat_helpers.S
+++ b/plat/qemu/common/aarch64/plat_helpers.S
@@ -67,6 +67,12 @@ func plat_secondary_cold_boot_setup
 	lsl	x0, x0, #PLAT_QEMU_HOLD_ENTRY_SHIFT
 	mov_imm	x2, PLAT_QEMU_HOLD_BASE
 
+	/* first check to see if we are about to be suspended */
+	ldr	x1, [x2, x0]
+	cmp	x1, #PLAT_QEMU_HOLD_STATE_SUSPEND
+	/* if so, use wfi for suspension */
+	beq	2f
+
 	/* Wait until we have a go */
 poll_mailbox:
 	ldr	x1, [x2, x0]
@@ -83,11 +89,30 @@ poll_mailbox:
 1:
 	wfe
 	b	poll_mailbox
+2:
+	wfi
+	/* if we wake up from wfi, the suspend is over, clear and poll the mailbox */
+	b	poll_mailbox
 endfunc plat_secondary_cold_boot_setup
 
 func plat_get_my_entrypoint
-	/* TODO support warm boot */
+	/* Preserve the link register */
+	mov	x1, x30
+	/* Write 0 to the mailbox upon the first call */
+	mov_imm	x0, PLAT_QEMU_TRUSTED_MAILBOX_BASE
+	str	xzr, [x0]
+	bl	plat_is_my_cpu_primary
+	cbz	w0, do_sec_entrypoint
+	/* This is the primary entrypoint */
 	mov	x0, #0
+	b	done_entrypoint
+do_sec_entrypoint:
+	mov_imm	x0, PLAT_QEMU_TRUSTED_MAILBOX_BASE
+	ldr	x0, [x0]
+	// hot loop until the mailbox is populated by the primary core
+	cbz	x0, do_sec_entrypoint
+done_entrypoint:
+	mov	x30, x1
 	ret
 endfunc plat_get_my_entrypoint
 
diff --git a/plat/qemu/common/qemu_bl31_setup.c b/plat/qemu/common/qemu_bl31_setup.c
index 1c5e0eaf7..0f2b7193b 100644
--- a/plat/qemu/common/qemu_bl31_setup.c
+++ b/plat/qemu/common/qemu_bl31_setup.c
@@ -80,6 +80,7 @@ static entry_point_info_t bl33_image_ep_info;
 static entry_point_info_t rmm_image_ep_info;
 #endif
 static struct transfer_list_header *bl31_tl;
+void __dead2 plat_secondary_cold_boot_setup(void);
 
 /*******************************************************************************
  * Perform any BL3-1 early platform setup.  Here is an opportunity to copy
@@ -114,6 +115,11 @@ void bl31_early_platform_setup2(u_register_t arg0, u_register_t arg1,
 
 	bl_params_node_t *bl_params = params_from_bl2->head;
 
+	// We hacked the bl1 function to wait for any signal like this...
+	// Should not be used in production
+	uintptr_t *mailbox = (uintptr_t *)PLAT_QEMU_TRUSTED_MAILBOX_BASE;
+	*mailbox = (uintptr_t)&plat_secondary_cold_boot_setup;
+
 	/*
 	 * Copy BL33, BL32 and RMM (if present), entry point information.
 	 * They are stored in Secure RAM, in BL2's address space.
diff --git a/plat/qemu/qemu/include/platform_def.h b/plat/qemu/qemu/include/platform_def.h
index 7dd7dcda5..460bd47ce 100644
--- a/plat/qemu/qemu/include/platform_def.h
+++ b/plat/qemu/qemu/include/platform_def.h
@@ -111,8 +111,9 @@
 					 PLAT_QEMU_HOLD_ENTRY_SIZE)
 #define PLAT_QEMU_HOLD_ENTRY_SHIFT	3
 #define PLAT_QEMU_HOLD_ENTRY_SIZE	(1 << PLAT_QEMU_HOLD_ENTRY_SHIFT)
-#define PLAT_QEMU_HOLD_STATE_WAIT	0
-#define PLAT_QEMU_HOLD_STATE_GO		1
+#define PLAT_QEMU_HOLD_STATE_WAIT			0
+#define PLAT_QEMU_HOLD_STATE_GO				1
+#define PLAT_QEMU_HOLD_STATE_SUSPEND	2
 
 #define BL_RAM_BASE			(SHARED_RAM_BASE + SHARED_RAM_SIZE)
 #define BL_RAM_SIZE			(SEC_SRAM_SIZE - SHARED_RAM_SIZE)
diff --git a/plat/qemu/qemu_sbsa/include/platform_def.h b/plat/qemu/qemu_sbsa/include/platform_def.h
index b0282a077..893bde3fd 100644
--- a/plat/qemu/qemu_sbsa/include/platform_def.h
+++ b/plat/qemu/qemu_sbsa/include/platform_def.h
@@ -111,8 +111,9 @@
 					 PLAT_QEMU_HOLD_ENTRY_SIZE)
 #define PLAT_QEMU_HOLD_ENTRY_SHIFT	3
 #define PLAT_QEMU_HOLD_ENTRY_SIZE	(1 << PLAT_QEMU_HOLD_ENTRY_SHIFT)
-#define PLAT_QEMU_HOLD_STATE_WAIT	0
-#define PLAT_QEMU_HOLD_STATE_GO		1
+#define PLAT_QEMU_HOLD_STATE_WAIT			0
+#define PLAT_QEMU_HOLD_STATE_GO				1
+#define PLAT_QEMU_HOLD_STATE_SUSPEND	2
 
 #define BL_RAM_BASE			(SHARED_RAM_BASE + SHARED_RAM_SIZE)
 #define BL_RAM_SIZE			(SEC_SRAM_SIZE - SHARED_RAM_SIZE)
diff --git a/plat/qemu/qemu_sbsa/sbsa_pm.c b/plat/qemu/qemu_sbsa/sbsa_pm.c
index 7ce7beba9..c28bfdb7d 100644
--- a/plat/qemu/qemu_sbsa/sbsa_pm.c
+++ b/plat/qemu/qemu_sbsa/sbsa_pm.c
@@ -170,7 +170,14 @@ qemu_pwr_domain_pwr_down_wfi(const psci_power_state_t *target_state)
  ******************************************************************************/
 void qemu_pwr_domain_suspend(const psci_power_state_t *target_state)
 {
-	assert(false);
+	// Set up the mailbox to prepare for the interrupt coming back up
+	unsigned pos = plat_my_core_pos();
+	uint64_t *hold_base = (uint64_t *)PLAT_QEMU_HOLD_BASE;
+
+	// This seems odd, but at this point, the core should be running already
+	// Thus setting the mailbox for itself will only take effect when the next event
+	// arrived and the core is ready to process it (at poll mailbox loop).
+	hold_base[pos] = PLAT_QEMU_HOLD_STATE_SUSPEND;
 }
 
 /*******************************************************************************
@@ -193,7 +200,7 @@ void qemu_pwr_domain_on_finish(const psci_power_state_t *target_state)
  ******************************************************************************/
 void qemu_pwr_domain_suspend_finish(const psci_power_state_t *target_state)
 {
-	assert(false);
+	// Do nothing
 }
 
 /*******************************************************************************
@@ -207,6 +214,11 @@ static void __dead2 qemu_system_off(void)
 
 static void __dead2 qemu_system_reset(void)
 {
+	uintptr_t *mailbox = (uintptr_t *)PLAT_QEMU_TRUSTED_MAILBOX_BASE;
+
+	// Save us from the next boot up
+	*mailbox = 0;
+
 	mmio_write_32(SBSA_SECURE_EC_OFFSET, SBSA_SECURE_EC_CMD_REBOOT);
 	panic();
 }
-- 
2.43.0

